Module 1
Big O - worst-case scenario
3n^2 + n + 3 + 1
3n^2 is worst-case scenario

Nested for loops aren't ideal

Logarithmic runtime examples: binary search trees

Array: indexed list of values stored in a continuous block of memory
Adding/deleting an item from an array is an example of a linear runtime (O(n)), don't have memory available, we'd have to copy it
Accessing an element from an array is an example of a constant runtime

Python is written in C 

Linked list is composed of many nodes. Nodes are composed of a value and a pointer to next node in list
- Linked lists don't need to be contiguous
- Inserting new head is fast: created new node, it's the new head, constant runtime
- Deleting head is similar
- Searching for a node takes a long time, as there is no order requirement, a linear search
- Check if is tail by seeing if pointer points to None

Queues are FIFO, and stacks ares LIFO

Big O cheatsheet: https://www.bigocheatsheet.com/


OOP Analogies:

Encapsulation 
Each object keeps its state private. Other objects don’t have direct access to this state. 
You can feed, play with, and have the cat sleep, but you can’t affect its mood, hunger, or energy

Abstraction
A coffee maker, a few public methods but you don’t see everything under the hood because you
don't need to 

Inheritance 
Ability to reuse common logic but also extract unique logic into a separate class

Polymorphism
The ability to take many shapes. Method overriding. Method used for parent class that we 
want to use for children.


Module 4 notes

Breadth-first printing
- Don't want to search deep. don't want to go down one road, want to 
cast a wide net

Depth-first printing
- A maze is a good example

---------------------------

Pre-order traversal
- print when each is reached (traversed) for the first time

In-order traversal
- print when each is reached for the second time

Post-order traversal
- print when each is reached for the third time